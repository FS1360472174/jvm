** gc 回收过程 **
1.判断对象是否存活
判断对象是否存活，早期采用对象是否存在引用来判断，但是这个方法对循环引用不起作用，
所以现在一般不采用，一般使用引用链方法，判断root 到对象是否存在路径

2.标记
将不再存活的对象标记为可清除

3.清除

** 垃圾回收算法 **
1.Mark-Sweep(标记清除算法)
最基本的垃圾回收算法，基于** gc 回收过程中描述一样**
存在着两点缺陷
从时间上来看，标记和清除过程都特别耗时
从空间上来看，垃圾回收后，会产生很多小的内存碎片。造成内存的不连续，无法给大的对象分配内存空间，
更快的触发下一次gc

2.复制算法
将内存分为两块，一次只使用一块，当执行垃圾回收时，将存活的对象copy到未使用的内存空间，然后将剩下的内存一次性全部清除

优点：时间上，不需要标记操作了，提高了清除效率，空间上解决了内存碎片化问题。
缺点：有另一块内存空间闲置不用，造成了内存浪费；
需要保证较小一块内存空间>每次gc时候存活的对象大小；
当存活对象比较多，复制操作就会比较耗时

3.标记-整理
在标记-清除 算法基础上，改进了清除过程
标记好对象后，不进行清理，将存活的对象移除到一端，然后将边界以外的对象都清除掉

优点：不需要考虑gc时，存活对象的占比
缺点:相比较复制算法，效率要低

4.分代收集
根据对象存活的周期，将对象分成不同的内存区域，比如新生代，老生代。
不同的区域采用不同的垃圾回收算法。
比如新生代可以采用复制算法
老生代采用 标记-整理算法

